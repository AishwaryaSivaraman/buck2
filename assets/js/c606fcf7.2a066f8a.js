"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9738],{17547:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"prelude/rules/rust_library","title":"rust_library","description":"name","source":"@site/../docs/prelude/rules/rust_library.md","sourceDirName":"prelude/rules","slug":"/prelude/rules/rust_library","permalink":"/docs/prelude/rules/rust_library","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"ruleSidebar","previous":{"title":"rust_binary","permalink":"/docs/prelude/rules/rust_binary"},"next":{"title":"rust_test","permalink":"/docs/prelude/rules/rust_test"}}');var r=t(74848),i=t(28453);t(56289);const l={},a="rust_library",o={},d=[{value:"name",id:"name",level:2},{value:"Parameters",id:"parameters",level:4},{value:"Details",id:"details",level:4}];function c(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"rust_library",children:"rust_library"})}),"\n",(0,r.jsx)(s.h2,{id:"name",children:"name"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"def name(\n    *,\n    name: str,\n    default_target_platform: None | str = ...,\n    target_compatible_with: list[str] = ...,\n    compatible_with: list[str] = ...,\n    exec_compatible_with: list[str] = ...,\n    visibility: list[str] = ...,\n    within_view: list[str] = ...,\n    metadata: OpaqueMetadata = ...,\n    tests: list[str] = ...,\n    modifiers: OpaqueMetadata = ...,\n    _apple_platforms: dict[str, str] = ...,\n    _cxx_toolchain: str = ...,\n    _exec_os_type: str = ...,\n    _rust_internal_tools_toolchain: str = ...,\n    _rust_toolchain: str = ...,\n    _target_os_type: str = ...,\n    _workspaces: list[str] = ...,\n    clippy_configuration: None | str = ...,\n    contacts: list[str] = ...,\n    coverage: bool = ...,\n    crate: None | str = ...,\n    crate_dynamic: None | str = ...,\n    crate_root: None | str = ...,\n    default_host_platform: None | str = ...,\n    default_platform: None | str = ...,\n    deps: list[str] = ...,\n    doc_deps: list[str] = ...,\n    doc_env: dict[str, str] = ...,\n    doc_link_style: None | str = ...,\n    doc_linker_flags: list[str] = ...,\n    doc_named_deps: list[(str, str)] | dict[str, str] = ...,\n    doctests: None | bool = ...,\n    edition: None | str = ...,\n    env: dict[str, str] = ...,\n    exported_linker_flags: list[str] = ...,\n    exported_post_linker_flags: list[str] = ...,\n    features: list[str] = ...,\n    flagged_deps: list[(str, list[str])] = ...,\n    incremental_enabled: bool = ...,\n    labels: list[str] = ...,\n    licenses: list[str] = ...,\n    link_style: None | str = ...,\n    linker_flags: list[str] = ...,\n    mapped_srcs: dict[str, str] = ...,\n    named_deps: list[(str, str)] | dict[str, str] = ...,\n    preferred_linkage: str = ...,\n    proc_macro: bool = ...,\n    resources: list[str] | dict[str, str] = ...,\n    rustc_flags: list[str] = ...,\n    rustdoc_flags: list[str] = ...,\n    separate_debug_info: bool = ...,\n    soname: None | str = ...,\n    srcs: list[str] = ...,\n    supports_python_dlopen: None | bool = ...,\n) -> None\n"})}),"\n",(0,r.jsx)(s.p,{children:"A rust_library() rule builds a native library from the supplied set of Rust source files and dependencies."}),"\n",(0,r.jsx)(s.h4,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"name"}),": name of the target"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"default_target_platform"}),": specifies the default target platform, used when no platforms are specified on the command line"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"target_compatible_with"}),": a list of constraints that are required to be satisfied for this target to be compatible with a configuration"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"compatible_with"}),": a list of constraints that are required to be satisfied for this target to be compatible with a configuration"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"exec_compatible_with"}),": a list of constraints that are required to be satisfied for this target to be compatible with an execution platform"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"visibility"}),": a list of visibility patterns restricting what targets can depend on this one"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"within_view"}),": a list of visibility patterns restricting what this target can depend on"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"metadata"}),": a key-value map of metadata associated with this target"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"tests"}),": a list of targets that provide tests for this one"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"modifiers"}),": an array of modifiers associated with this target"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"_workspaces"}),": Internal implementation detail of Rust workspaces. This should not be set manually and will be replaced in favor of metadata in a future version of buck2."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"crate_root"}),": Set the name of the top-level source file for the crate, which can be used to override the default (see ",(0,r.jsx)(s.code,{children:"srcs"}),")."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"deps"}),": The set of dependencies of this rule. Currently, this supports rust_library and prebuilt_rust_library rules."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"doc_deps"}),": The set of dependencies of this rule. Currently, this supports rust_library and prebuilt_rust_library rules."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"doc_env"}),": Set environment variables for this rule's invocations of rustc. The environment variable values may include macros which are expanded."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"doc_link_style"}),": Determines whether to build and link this rule's dependencies statically or dynamically. Can be either ",(0,r.jsx)(s.code,{children:"static"}),", ",(0,r.jsx)(s.code,{children:"static_pic"})," or ",(0,r.jsx)(s.code,{children:"shared"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"doc_linker_flags"}),": The set of additional flags to pass to the linker."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"doc_named_deps"}),": Add crate dependencies and define a local name by which to use that dependency by. This allows a crate to have multiple dependencies with the same crate name. For example: ",(0,r.jsx)(s.code,{children:'named_deps = {"local_name", ":some_rust_crate" }'}),". The dependencies may also be non-Rust, but the alias is ignored. It has no effect on the symbols provided by a C/C++ library."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"edition"}),": Set the language edition to be used for this rule. Can be set to any edition the compiler supports (",(0,r.jsx)(s.code,{children:"2018"})," right now). If unset it uses the compiler's default (",(0,r.jsx)(s.code,{children:"2015"}),")."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"env"}),": Set environment variables for this rule's invocations of rustc. The environment variable values may include macros which are expanded."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"exported_linker_flags"}),": A set of additional flag to pass before this item on the link line, even if this items is compiled to a DSO."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"exported_post_linker_flags"}),": A set of additional flag to pass after this item on the link line, even if this items is compiled to a DSO."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"features"}),": The set of features to be enabled for this rule."]}),"\n",(0,r.jsxs)(s.p,{children:["These are passed to ",(0,r.jsx)(s.code,{children:"rustc"})," with ",(0,r.jsx)(s.code,{children:'--cfg feature="{feature}"'}),", and can be used in the code with ",(0,r.jsx)(s.code,{children:'#[cfg(feature = "{feature}")]'}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"link_style"}),": Determines whether to build and link this rule's dependencies statically or dynamically. Can be either ",(0,r.jsx)(s.code,{children:"static"}),", ",(0,r.jsx)(s.code,{children:"static_pic"})," or ",(0,r.jsx)(s.code,{children:"shared"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"linker_flags"}),": The set of additional flags to pass to the linker."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"mapped_srcs"}),": Add source files along with a local path mapping. Rust is sensitive to the layout of source files, as the directory structure follows the module structure. However this is awkward if the source file is, for example, generated by another rule. In this case, you can set up a mapping from the actual source path to something that makes sense locally. For example ",(0,r.jsx)(s.code,{children:'mapped_srcs = {":generate-module", "src/generated.rs" }'}),". These are added to the regular ",(0,r.jsx)(s.code,{children:"srcs"}),", so a file should not be listed in both."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"named_deps"}),": Add crate dependencies and define a local name by which to use that dependency by. This allows a crate to have multiple dependencies with the same crate name. For example: ",(0,r.jsx)(s.code,{children:'named_deps = {"local_name", ":some_rust_crate" }'}),". The dependencies may also be non-Rust, but the alias is ignored. It has no effect on the symbols provided by a C/C++ library."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"rustc_flags"}),": The set of additional compiler flags to pass to ",(0,r.jsx)(s.code,{children:"rustc"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"soname"}),': Sets the soname ("shared object name") of any shared library produced from this rule. The default value is based on the full rule name. The macro ',(0,r.jsx)(s.code,{children:"$(ext)"})," will be replaced with a platform-appropriate extension. An argument can be provided, which is a library version. For example ",(0,r.jsx)(s.code,{children:"soname = 'libfoo.$(ext 2.3)'"})," will be ",(0,r.jsx)(s.code,{children:"libfoo.2.3.dylib"})," on Mac and ",(0,r.jsx)(s.code,{children:"libfoo.so.2.3"})," on Linux."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"srcs"}),": The set of Rust source files to be compiled by this rule."]}),"\n",(0,r.jsxs)(s.p,{children:["One of the source files is the root module of the crate. By default this is ",(0,r.jsx)(s.code,{children:"lib.rs"})," for libraries, ",(0,r.jsx)(s.code,{children:"main.rs"})," for executables, or\nthe crate's name with ",(0,r.jsx)(s.code,{children:".rs"})," appended. This can be overridden with the ",(0,r.jsx)(s.code,{children:"crate_root"})," rule parameter."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:"details",children:"Details"}),"\n",(0,r.jsxs)(s.p,{children:["If you invoke a build with the ",(0,r.jsx)(s.code,{children:"check"})," flavor, then Buck will invoke rustc\nto check the code (typecheck, produce warnings, etc), but won't generate an executable code.\nWhen applied to binaries it produces no output; for libraries it produces metadata for\nconsumers of the library."]}),"\n",(0,r.jsx)(s.p,{children:"Note: Buck is currently tested with (and therefore supports) version 1.32.0 of Rust."}),"\n",(0,r.jsx)(s.p,{children:"Examples:"}),"\n",(0,r.jsxs)(s.p,{children:["For more examples, check out our ",(0,r.jsx)(s.a,{href:"https://github.com/facebook/buck/tree/dev/test/com/facebook/buck/rust/testdata/",children:"integration tests"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"\nrust_library(\n  name='greeting',\n  srcs=[\n    'greeting.rs',\n  ],\n  deps=[\n    ':join',\n  ],\n)\n\n"})})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,s,t)=>{t.d(s,{R:()=>l,x:()=>a});var n=t(96540);const r={},i=n.createContext(r);function l(e){const s=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),n.createElement(i.Provider,{value:s},e.children)}}}]);